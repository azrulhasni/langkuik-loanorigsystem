import {
  __reExport
} from "./chunk-KKNQZGBY.js";

// external:@vaadin/vaadin-themable-mixin
var vaadin_themable_mixin_exports = {};
__reExport(vaadin_themable_mixin_exports, vaadin_themable_mixin_star);
import * as vaadin_themable_mixin_star from "@vaadin/vaadin-themable-mixin";

// node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js
import { idlePeriod } from "@polymer/polymer/lib/utils/async.js";
import { Debouncer } from "@polymer/polymer/lib/utils/debounce.js";
import { enqueueDebouncer } from "@polymer/polymer/lib/utils/flush.js";

// node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-helper.js
var DirHelper = class {
  static detectScrollType() {
    const dummy = document.createElement("div");
    dummy.textContent = "ABCD";
    dummy.dir = "rtl";
    dummy.style.fontSize = "14px";
    dummy.style.width = "4px";
    dummy.style.height = "1px";
    dummy.style.position = "absolute";
    dummy.style.top = "-1000px";
    dummy.style.overflow = "scroll";
    document.body.appendChild(dummy);
    let cachedType = "reverse";
    if (dummy.scrollLeft > 0) {
      cachedType = "default";
    } else {
      dummy.scrollLeft = 2;
      if (dummy.scrollLeft < 2) {
        cachedType = "negative";
      }
    }
    document.body.removeChild(dummy);
    return cachedType;
  }
  static getNormalizedScrollLeft(scrollType2, direction, element) {
    const { scrollLeft } = element;
    if (direction !== "rtl" || !scrollType2) {
      return scrollLeft;
    }
    switch (scrollType2) {
      case "negative":
        return element.scrollWidth - element.clientWidth + scrollLeft;
      case "reverse":
        return element.scrollWidth - element.clientWidth - scrollLeft;
    }
    return scrollLeft;
  }
  static setNormalizedScrollLeft(scrollType2, direction, element, scrollLeft) {
    if (direction !== "rtl" || !scrollType2) {
      element.scrollLeft = scrollLeft;
      return;
    }
    switch (scrollType2) {
      case "negative":
        element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;
        break;
      case "reverse":
        element.scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;
        break;
      default:
        element.scrollLeft = scrollLeft;
        break;
    }
  }
};

// node_modules/@vaadin/vaadin-element-mixin/vaadin-dir-mixin.js
var directionSubscribers = [];
var directionUpdater = function() {
  const documentDir = getDocumentDir();
  directionSubscribers.forEach((element) => {
    alignDirs(element, documentDir);
  });
};
var scrollType;
var directionObserver = new MutationObserver(directionUpdater);
directionObserver.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
var alignDirs = function(element, documentDir) {
  if (documentDir) {
    element.setAttribute("dir", documentDir);
  } else {
    element.removeAttribute("dir");
  }
};
var getDocumentDir = function() {
  return document.documentElement.getAttribute("dir");
};
var DirMixin = (superClass) => class VaadinDirMixin extends superClass {
  static get properties() {
    return {
      dir: {
        type: String,
        readOnly: true
      }
    };
  }
  static finalize() {
    super.finalize();
    if (!scrollType) {
      scrollType = DirHelper.detectScrollType();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.hasAttribute("dir")) {
      this.__subscribe();
      alignDirs(this, getDocumentDir());
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name !== "dir") {
      return;
    }
    const newValueEqlDocDir = newValue === getDocumentDir() && directionSubscribers.indexOf(this) === -1;
    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;
    const newDiffValue = newValue !== getDocumentDir() && oldValue === getDocumentDir();
    if (newValueEqlDocDir || newValueEmptied) {
      this.__subscribe();
      alignDirs(this, getDocumentDir());
    } else if (newDiffValue) {
      this.__subscribe(false);
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__subscribe(false);
    this.removeAttribute("dir");
  }
  __subscribe(push = true) {
    if (push) {
      directionSubscribers.indexOf(this) === -1 && directionSubscribers.push(this);
    } else {
      directionSubscribers.indexOf(this) > -1 && directionSubscribers.splice(directionSubscribers.indexOf(this), 1);
    }
  }
  __getNormalizedScrollLeft(element) {
    return DirHelper.getNormalizedScrollLeft(scrollType, this.getAttribute("dir") || "ltr", element);
  }
  __setNormalizedScrollLeft(element, scrollLeft) {
    return DirHelper.setNormalizedScrollLeft(scrollType, this.getAttribute("dir") || "ltr", element, scrollLeft);
  }
};

// node_modules/@vaadin/vaadin-element-mixin/vaadin-element-mixin.js
import { usageStatistics } from "@vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js";
if (!window.Vaadin) {
  window["Vaadin"] = {};
}
window["Vaadin"].registrations = window.Vaadin.registrations || [];
window["Vaadin"].developmentModeCallback = window.Vaadin.developmentModeCallback || {};
window["Vaadin"].developmentModeCallback["vaadin-usage-statistics"] = function() {
  if (usageStatistics) {
    usageStatistics();
  }
};
var statsJob;
var registered = /* @__PURE__ */ new Set();
var ElementMixin = (superClass) => class VaadinElementMixin extends DirMixin(superClass) {
  static finalize() {
    super.finalize();
    const { is } = this;
    if (is && !registered.has(is)) {
      window.Vaadin.registrations.push(this);
      registered.add(is);
      if (window.Vaadin.developmentModeCallback) {
        statsJob = Debouncer.debounce(
          statsJob,
          idlePeriod,
          () => {
            window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
          }
        );
        enqueueDebouncer(statsJob);
      }
    }
  }
  constructor() {
    super();
    if (document.doctype === null) {
      console.warn(
        'Vaadin components require the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
      );
    }
  }
};

export {
  vaadin_themable_mixin_exports,
  ElementMixin
};
/**
@license
Copyright (c) 2020 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/
//# sourceMappingURL=chunk-VM7WIMYX.js.map
